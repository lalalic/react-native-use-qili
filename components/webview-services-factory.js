import React from "react"
import ProvideWeb from "./provider-web" 
import { Qili } from "../store"
import isAccessible from "../tools/is-accessible"

/**
 * It's to bring the features of an extension to app 
 * @param {*} extension:  usually it's from bridge-chrome-extension/index.js 
 * generated by scripts/chrome-extensiont-to-service.js, which merge all features of of the extension
 * into a nodejs module in order to be usable in app
 * @returns 
 */
export default function webviewServicesFactory(extension, targets){
    const {uris, services, subscriptAsHelper, ...Bros}=extension

    const target=id=>targets ? targets[id] : true

    const webviews=Object.entries(Bros).reduce((all, [id, bro])=>{
        if(!target(id))
            return all
        const Context=React.createContext({})
        all[id]={
            Provider(props){
                return (
                    <ProvideWeb id={id}
                        Context={Context}
                        uri={uris[id]}
                        bro={bro}
                        {...props}
                        >
                    </ProvideWeb>
                    )
            },
            
            useService(){
                return React.useContext(Context)
            }
        }

        return all
    },{})

    const proxies=Object.entries(services).reduce((all, [id, bro])=>{
        if(!target(id)){
            return all
        }
        all[id]={
            useService({remote, helper}={}){
                const banned=typeof(remote)=="undefined" ? !(bro.accessible ? isAccessible(bro.accessible) : true) : remote
                const service=React.useMemo(()=>{
                    if(banned){
                        return new Proxy({},{
                            get(target, fnKey){
                                return (...args)=>{
                                    const message={fnKey, args, $service: id}
                                    console.debug(message)
                                    return Qili.bridge.askThenWaitAnswer(message)
                                }
                            }
                        })
                    }
                    return bro()
                },[banned])

                React.useEffect(()=>{
                    if(helper && !banned){
                        const env=makeHelperEnv()
                        const unsub=subscriptAsHelper({helper,...env})
                        Object.keys(env.window.bros).filter("id").forEach(k=>delete env.window.bros[k])
                        return unsub
                    }
                },[helper,banned])
                return service
            }
        }

        return all
    },{})

    return  {
        ...webviews, ...proxies,
        subscriptAsHelper({helper, ...props}){
            return subscriptAsHelper({helper, ...makeHelperEnv(), ...props})
        }
    }
}

function makeHelperEnv(){
    const empty=()=>({})
    const proxy=new Proxy({},{get:(_,key)=>empty})
    const chrome={
        tabs:proxy,
        browserAction:proxy,
        storage:{
            sync:{
                get(type, callback){
                    callback?.(0)
                },
                set(){

                }
            }
        },
        runtime:{
            onMessage:proxy,
            onStartup:proxy,
            onInstalled:proxy,
            onSuspend:{
                addListener(unsub){
                    unsubscribe=unsub
                }
            }
        }
    }

    const window={isLocal:true}

    return {Qili:Qili.bridge, chrome, window}
}
